{"version":3,"mappings":"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","names":["proxy","prop","is_array","s","component","effect","e.props_invalid_value","$.prop","$.user_pre_effect","$$anchor","$$component"],"ignoreList":[0,1,2,3,4,5,6,7],"sources":["../../../../../../node_modules/svelte/src/internal/shared/errors.js","../../../../../../node_modules/svelte/src/internal/client/proxy.js","../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js","../../../../../../node_modules/svelte/src/legacy/legacy-client.js","../../../../../../node_modules/svelte/src/index-client.js","../../../../../generated/client-optimized/matchers.js","../../../../../generated/root.svelte","../../../../../generated/root.js","../../../../../generated/client-optimized/app.js"],"sourcesContent":["/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_default_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_outside_component\");\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"store_invalid_shape\");\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_element_invalid_this_value\");\n\t}\n}","/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, current_component_context, untrack, current_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_FROZEN_SYMBOL, STATE_SYMBOL } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {ProxyStateObject<T> | T}\n */\nexport function proxy(value, parent = null, prev) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// Since original parent relationship gets lost, we need to copy over ancestor owners\n\t\t\t\t\t// into current metadata. The object might still exist on both, so we need to widen it.\n\t\t\t\t\twiden_ownership(metadata, metadata);\n\t\t\t\t\tmetadata.parent = parent;\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].parent = parent;\n\n\t\t\t\tif (prev) {\n\t\t\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tconst prev_owners = prev?.v?.[STATE_SYMBOL]?.owners;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners =\n\t\t\t\t\t\tparent === null\n\t\t\t\t\t\t\t? current_component_context !== null\n\t\t\t\t\t\t\t\t? new Set([current_component_context.function])\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t: new Set();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/** @type {ProxyHandler<ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields – otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// create a source, but only if it's an own property and not a prototype property\n\t\tif (s === undefined && (!(prop in target) || get_descriptor(target, prop)?.writable)) {\n\t\t\ts = source(proxy(target[prop], metadata));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (\n\t\t\ts !== undefined ||\n\t\t\t(current_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\tconst prop_metadata = value?.[STATE_SYMBOL];\n\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t}\n\t\t\tcheck_ownership(metadata);\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\tif (descriptor?.set) {\n\t\t\tdescriptor.set.call(receiver, value);\n\t\t} else {\n\t\t\ttarget[prop] = value;\n\t\t}\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\te.state_prototype_fixed();\n\t};\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\tvar metadata = value[STATE_SYMBOL];\n\t\tif (metadata) {\n\t\t\treturn metadata.p;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\t// Find the original target if the value is proxied.\n\tvar proxy_target = bound_value && bound_value[STATE_SYMBOL]?.t;\n\treturn bound_value === element_or_component || proxy_target === element_or_component;\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, is_signals_recorded, untrack, update } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP } from '../constants.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return false;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar prop_value = /** @type {V} */ (props[key]);\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (lazy && fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\tvar current = get(current_value);\n\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\tget(current_value); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\treturn current;\n\t};\n}\n","/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { flush_sync, get } from '../internal/client/runtime.js';\nimport { define_property } from '../internal/shared/utils.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * \timmutable?: boolean;\n * \thydrate?: boolean;\n * \trecover?: boolean;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * \timmutable?: boolean;\n\t * \thydrate?: boolean;\n\t * \trecover?: false;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is increment on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\tflush_sync();\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(fn);\n}\n","/** @import { ComponentContext, ComponentContextLegacy } from '#client' */\n/** @import { EventDispatcher } from './index.js' */\n/** @import { NotFunction } from './internal/types.js' */\nimport { current_component_context, flush_sync, untrack } from './internal/client/runtime.js';\nimport { is_array } from './internal/shared/utils.js';\nimport { user_effect } from './internal/client/index.js';\nimport * as e from './internal/client/errors.js';\nimport { lifecycle_outside_component } from './internal/shared/errors.js';\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component('onMount');\n\t}\n\n\tif (current_component_context.l !== null) {\n\t\tinit_update_callbacks(current_component_context).m.push(fn);\n\t} else {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component('onDestroy');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @deprecated Use callback props and/or the `$host()` rune instead — see https://svelte-5-preview.vercel.app/docs/deprecations#createeventdispatcher\n * @template {Record<string, any>} [EventMap = any]\n * @returns {EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('createEventDispatcher');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tcomponent_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @deprecated Use `$effect.pre` instead — see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component('beforeUpdate');\n\t}\n\n\tif (current_component_context.l === null) {\n\t\te.lifecycle_legacy_only('beforeUpdate');\n\t}\n\n\tinit_update_callbacks(current_component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @deprecated Use `$effect` instead — see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component('afterUpdate');\n\t}\n\n\tif (current_component_context.l === null) {\n\t\te.lifecycle_legacy_only('afterUpdate');\n\t}\n\n\tinit_update_callbacks(current_component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\tvar l = /** @type {ComponentContextLegacy} */ (context).l;\n\treturn (l.u ??= { a: [], b: [], m: [] });\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\nexport { hydrate, mount, unmount } from './internal/client/render.js';\n\nexport {\n\tgetContext,\n\tgetAllContexts,\n\thasContext,\n\tsetContext,\n\ttick,\n\tuntrack\n} from './internal/client/runtime.js';\n\nexport { createRawSnippet } from './internal/client/dom/blocks/snippet.js';\n","export const matchers = {};","<!-- This file is generated by @sveltejs/kit — do not edit it! -->\n<svelte:options runes={true} />\n<script>\n\timport { setContext, onMount, tick } from 'svelte';\n\timport { browser } from '$app/environment';\n\n\t// stores\n\tlet { stores, page, constructors, components = [], form, data_0 = null, data_1 = null } = $props();\n\n\tif (!browser) {\n\t\tsetContext('__svelte__', stores);\n\t}\n\n\tif (browser) {\n\t\t$effect.pre(() => stores.page.set(page));\n\t} else {\n\t\tstores.page.set(page);\n\t}\n\t$effect(() => {\n\t\tstores;page;constructors;components;form;data_0;data_1;\n\t\tstores.page.notify();\n\t});\n\n\tlet mounted = $state(false);\n\tlet navigated = $state(false);\n\tlet title = $state(null);\n\n\tonMount(() => {\n\t\tconst unsubscribe = stores.page.subscribe(() => {\n\t\t\tif (mounted) {\n\t\t\t\tnavigated = true;\n\t\t\t\ttick().then(() => {\n\t\t\t\t\ttitle = document.title || 'untitled page';\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tmounted = true;\n\t\treturn unsubscribe;\n\t});\n</script>\n\n{#if constructors[1]}\n\t<!-- svelte-ignore binding_property_non_reactive -->\n\t<svelte:component this={constructors[0]} bind:this={components[0]} data={data_0}>\n\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t<svelte:component this={constructors[1]} bind:this={components[1]} data={data_1} {form} />\n\t</svelte:component>\n{:else}\n\t<!-- svelte-ignore binding_property_non_reactive -->\n\t<svelte:component this={constructors[0]} bind:this={components[0]} data={data_0} {form} />\n{/if}\n\n{#if mounted}\n\t<div id=\"svelte-announcer\" aria-live=\"assertive\" aria-atomic=\"true\" style=\"position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px\">\n\t\t{#if navigated}\n\t\t\t{title}\n\t\t{/if}\n\t</div>\n{/if}","import { asClassComponent } from 'svelte/legacy';\nimport Root from './root.svelte';\nexport default asClassComponent(Root);","export { matchers } from './matchers.js';\n\nexport const nodes = [\n\t() => import('./nodes/0'),\n\t() => import('./nodes/1'),\n\t() => import('./nodes/2')\n];\n\nexport const server_loads = [];\n\nexport const dictionary = {\n\t\t\"/\": [2]\n\t};\n\nexport const hooks = {\n\thandleError: (({ error }) => { console.error(error) }),\n\n\treroute: (() => {})\n};\n\nexport { default as root } from '../root.js';"],"file":"_app/immutable/entry/app.x0MIonw4.js"}