{"version":3,"file":"disclose-version.C8yWjxTa.js","sources":["../../../../../../node_modules/svelte/src/internal/client/warnings.js","../../../../../../node_modules/svelte/src/constants.js","../../../../../../node_modules/svelte/src/internal/client/dom/hydration.js","../../../../../../node_modules/svelte/src/internal/client/dom/operations.js","../../../../../../node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../../../node_modules/svelte/src/internal/client/dom/template.js","../../../../../../node_modules/svelte/src/version.js","../../../../../../node_modules/svelte/src/internal/disclose-version.js"],"sourcesContent":["/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\nvar bold = 'font-weight: bold';\nvar normal = 'font-weight: normal';\n\n/**\n * `%binding%` (%location%) is binding to a non-reactive property\n * @param {string} binding\n * @param {string | undefined | null} [location]\n */\nexport function binding_property_non_reactive(binding, location) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] binding_property_non_reactive\\n%c${location ? `\\`${binding}\\` (${location}) is binding to a non-reactive property` : `\\`${binding}\\` is binding to a non-reactive property`}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"binding_property_non_reactive\");\n\t}\n}\n\n/**\n * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value\n * @param {string} attribute\n * @param {string} html\n * @param {string} value\n */\nexport function hydration_attribute_changed(attribute, html, value) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_attribute_changed\\n%cThe \\`${attribute}\\` attribute on \\`${html}\\` changed its value between server and client renders. The client value, \\`${value}\\`, will be ignored in favour of the server value`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_attribute_changed\");\n\t}\n}\n\n/**\n * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value\n * @param {string | undefined | null} [location]\n */\nexport function hydration_html_changed(location) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_html_changed\\n%c${location ? `The value of an \\`{@html ...}\\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : \"The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_html_changed\");\n\t}\n}\n\n/**\n * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%\n * @param {string | undefined | null} [location]\n */\nexport function hydration_mismatch(location) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_mismatch\\n%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : \"Hydration failed because the initial UI does not match what was rendered on the server\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_mismatch\");\n\t}\n}\n\n/**\n * The `render` function passed to `createRawSnippet` should return HTML for a single element\n */\nexport function invalid_raw_snippet_render() {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] invalid_raw_snippet_render\\n%cThe \\`render\\` function passed to \\`createRawSnippet\\` should return HTML for a single element`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"invalid_raw_snippet_render\");\n\t}\n}\n\n/**\n * Tried to unmount a component that was not mounted\n */\nexport function lifecycle_double_unmount() {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] lifecycle_double_unmount\\n%cTried to unmount a component that was not mounted`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"lifecycle_double_unmount\");\n\t}\n}\n\n/**\n * %parent% passed a value to %child% with `bind:`, but the value is owned by %owner%. Consider creating a binding between %owner% and %parent%\n * @param {string} parent\n * @param {string} child\n * @param {string} owner\n */\nexport function ownership_invalid_binding(parent, child, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_binding\\n%c${parent} passed a value to ${child} with \\`bind:\\`, but the value is owned by ${owner}. Consider creating a binding between ${owner} and ${parent}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_binding\");\n\t}\n}\n\n/**\n * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\n * @param {string | undefined | null} [component]\n * @param {string | undefined | null} [owner]\n */\nexport function ownership_invalid_mutation(component, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_mutation\\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \\`bind:\\`, or use a callback instead` : \"Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_mutation\");\n\t}\n}\n\n/**\n * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results. Consider using `$state.is(a, b)` instead%details%\n * @param {string} operator\n * @param {string} details\n */\nexport function state_proxy_equality_mismatch(operator, details) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] state_proxy_equality_mismatch\\n%cReactive \\`$state(...)\\` proxies and the values they proxy have different identities. Because of this, comparisons with \\`${operator}\\` will produce unexpected results. Consider using \\`$state.is(a, b)\\` instead${details}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"state_proxy_equality_mismatch\");\n\t}\n}","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\tif (hydrate_node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\treturn (hydrate_node = /** @type {TemplateNode} */ (hydrate_node.nextSibling));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (hydrating) {\n\t\thydrate_node = node;\n\t}\n}\n\nexport function next() {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (node.nextSibling);\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/** @returns {Text} */\nexport function empty() {\n\treturn document.createTextNode('');\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function child(node) {\n\tif (!hydrating) {\n\t\treturn node.firstChild;\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (hydrate_node.firstChild);\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(empty());\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (fragment).firstChild;\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return first.nextSibling;\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = empty();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, is_text = false) {\n\tif (!hydrating) {\n\t\treturn /** @type {TemplateNode} */ (node.nextSibling);\n\t}\n\n\tvar next_sibling = /** @type {TemplateNode} */ (hydrate_node.nextSibling);\n\n\tvar type = next_sibling.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = empty();\n\t\tnext_sibling?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, EffectNodes, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { empty } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { current_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\nimport { queue_micro_task } from './task.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\t/** @type {Effect} */ (current_effect).nodes ??= { start, end };\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (node.firstChild);\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (clone.firstChild);\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (fragment.firstChild);\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (root.firstChild) {\n\t\t\t\t\tnode.appendChild(root.firstChild);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (root.firstChild);\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (clone.firstChild);\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = ns_template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return;\n\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tfor (const script of scripts) {\n\t\tvar clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// If node === script tag, replaceWith will do nothing because there's no parent yet,\n\t\t// waiting until that's the case using an effect solves this.\n\t\t// Don't do it in other circumstances or we could accidentally execute scripts\n\t\t// in an adjacent @html tag that was instantiated in the meantime.\n\t\tif (script === node) {\n\t\t\tqueue_micro_task(() => script.replaceWith(clone));\n\t\t} else {\n\t\t\tscript.replaceWith(clone);\n\t\t}\n\t}\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n */\nexport function text() {\n\tif (!hydrating) {\n\t\tvar t = empty();\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = empty()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = empty();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect & { nodes: EffectNodes }} */ (current_effect).nodes.end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '5.0.0-next.210';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n"],"names":["w.hydration_mismatch","next","child","text"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}